# Terraform User Guide

## Terraform Configuration Files
Terraform configurations are written in HashiCorp Configuration Language (HCL), which is both human-readable and machine-friendly. 

Each resource block in a Terraform configuration file represents a piece of infrastructure, like a virtual machine, a storage bucket, or a network. Here's how to read a resource block:

```
resource "resource_type" "resource_name" {
  # Configuration arguments
}
```
`"resource_type"`: the type of resource you're managing, such as a `google_compute_instance` for a GCP VM instance.

`"resource_name"`: a unique name you assign to the resource within your Terraform configuration. This name is used to reference the resource in other parts of your configuration.

Consider this example:

```
resource "google_storage_bucket" "data_bucket" {
  name     = "my-data-bucket"
  location = "us-west1-c"
}
```

Within the resource block, statements such as `name` and `location` are considered arguments.

Now, lets include a second resource:
```
resource "google_compute_instance" "app_server" {
  name         = "app-instance"
  machine_type = "e2-medium"
  zone         = "us-west1-c"

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-9"
    }
  }

  network_interface {
    network = "default"
    access_config {
      // Left blank to assign a public IP address.
    }
  }

  depends_on = [
    google_storage_bucket.data_bucket
  ]

  lifecycle {
    create_before_destroy = true
  }
}
```

Resource blocks in Terraform can also contain **meta-arguments** such as `depends_on` or `lifecycle`, which are used to control specific behaviors of Terraform resources beyond the standard configuration parameters.

`depends_on`: allows explicit specification of dependencies between resources, ensuring Terraform creates or destroys them in a designated order; essential when one resource must be established before another can be configured.

`lifecycle`: modifies how Terraform manages resource creation, updates, and destruction, addressing complex behaviors such as minimizing downtime or managing immutable fields that necessitate resource replacement.



<br>

## Terraform CLI Commands

The Terraform CLI is at the heart of Terraform's functionality, enabling you to create, manage, and manipulate infrastructure resources efficiently. Understanding the Terraform CLI commands is essential for executing operations that range from initial configuration to the final destruction of resources. 

### Lifecycle Management
`terraform init`

Initializes a Terraform working directory by downloading and configuring the required providers and modules.

`terraform plan`

Creates an execution plan, showing what actions Terraform will take to change the infrastructure to match the configuration.

`terraform apply`

Applies the changes required to reach the desired state of the configuration, or the pre-determined set of actions generated by an execution plan.

`terraform destroy`

Destroys the Terraform-managed infrastructure, removing all resources previously created by `terraform apply`, based on the current configuration and state files.

### Formatting & Validation
`terraform fmt`

Automatically formats Terraform configuration files to a canonical format and style.

`terraform validate`

Validates the syntax and structure of the Terraform configuration files, ensuring they are properly formatted and logically correct.

### Resource Inspection
`terraform output`

Displays the outputs defined in the Terraform configuration, useful for extracting useful information or passing data to other tools.

`terraform show`

Provides human-readable output from a state or plan file, showing the resources that will be created, updated, or destroyed.

### State Management
`terraform state`

Provides advanced state management options, allowing you to view, modify, or remove resources within the Terraform state file.
- Usage example: `terraform state <subcommand>`

`terraform refresh`

Updates the Terraform state to reflect the current state of the infrastructure, without making any changes to the infrastructure itself.

### Import Existing Resources
`terraform import`

Imports an existing infrastructure into your Terraform state, allowing you to manage pre-existing resources with Terraform.

Usage example: `terraform import <TERRAFORM_RESOURCE_TYPE>.<RESOURCE_NAME> <RESOURCE_ID>`

- `terraform import google_compute_network.vpc projects/wondertix-app/global/networks/default`

- `terraform import google_sql_database_instance.prd projects/wondertix-app/instances/wtix-db-prd`

NOTE: When importing existing resources, always verify that the actual state of the resource detailed in the `terraform.tfstate` file matches the implementation found in the corresponding configuration file. To do this, run the command:

`terraform state show <YOUR_TF_RESOURCE>`

Example: `terraform state show google_computer_network.vpc`

<br>

## Project Files

Source: `./terraform/`
- `main.tf`: Manages the core Terraform setup, specifying the minimum required version and configuring the Google Cloud provider with essential credentials and project ID to manage resources within the specified project.
- `variables.tf`: Defines variables used across the project.
- `terraform.tfvars`: Contains variable values that are passed into the Terraform configuration, often used to set environment-specific settings.
- `outputs.tf`: Defines outputs after Terraform execution.
- `backend.tf`: Specifies the configuration for the backend, which is used by Terraform to store state files remotely, allowing for team collaboration and state locking.
- `terraform.tfstate`: Stores the state of your managed infrastructure and configuration, tracking resource metadata and dependencies. This file is crucial for Terraform to perform changes, updates, and deletions accurately.
- `terraform.lock.hcl`: Maintains a record of provider dependencies as a dependency lock file to ensure consistent configurations, preventing discrepancies between different runs and environments by locking provider versions.

<br>

## Common Workflows
- **Planning Changes:** Before applying changes, always run `terraform plan` to review what will be created, updated, or destroyed.
- **Applying Changes:** Execute `terraform apply` to apply the desired changes to your infrastructure.
- **Destroying Infrastructure:** Use `terraform destroy` when you need to completely remove all resources managed by Terraform.

<br>

## Best Practices
- **State Management:** Store Terraform state in a remote backend such as Google Cloud Storage to improve security and team collaboration.
- **Sensitive Information:** Use variables and secrets management practices to handle sensitive information, never hard-code credentials.
- **Version Control:** Use version control for your Terraform files to track changes and collaborate with team members.

<br>

## Troubleshooting
- **Initialization Errors:** If `terraform init` fails, check your network connection and access rights to the backend.
- **Plan and Apply Errors:** Ensure all required variables are supplied and that your GCP credentials are up-to-date.

<br>

## Managing Variables with `.tfvars` Files

- **Creating `.tfvars` Files:**
  Store environment-specific variables in separate `.tfvars` files, such as `dev.tfvars` for development and `prod.tfvars` for production environments.

- **Populating `.tfvars` Files:**
  Provide actual values for your Terraform configurations in these files. Keep sensitive information out of version control by referencing these files without tracking them in Git.

- **Using `.tfvars` Files in Commands:**
  Specify which `.tfvars` file to use with Terraform commands using the `-var-file` flag:
  ```sh
  terraform apply -var-file="path/to/your-file.tfvars"
```